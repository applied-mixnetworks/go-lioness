package lioness

import (
	"bytes"
	"fmt"
	"testing"
)

func TestBasicLionessEncrypt(t *testing.T) {
	var err error
	var key [LionessKeyLen]byte
	for i := 0; i < LionessKeyLen; i++ {
		key[i] = byte(i) & 0xff
	}

	plaintext := []byte("'What do we know,' he had said, 'of the world and the universe about us? Our means of receiving impressions are absurdly few, and our notions of surrounding objects infinitely narrow. We see things only as we are constructed to see them, and can gain no idea of their absolute nature. With five feeble senses we pretend to comprehend the boundlessly complex cosmos, yet other beings with wider, stronger, or different range of senses might not only see very differently the things we see, but might see and st")
	cipher := NewCipher(key, len(plaintext)) // key and block-size
	// Encrypt and see if it blows up.
	ciphertext, err := cipher.Encrypt(plaintext)
	if err != nil {
		t.Error(err)
		t.Fail()
	}
	message := []byte{}
	message, err = cipher.Decrypt(ciphertext)
	if err != nil {
		t.Error(err)
		t.Fail()
	}
	if !bytes.Equal(message, plaintext) {
		t.Error("decrypted ciphertext not equal plaintext")
		t.Fail()
	}
}

var draftTestVectors = []struct {
	key   [LionessKeyLen]byte
	block []byte
}{
	{
		key: [LionessKeyLen]byte{
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		},
		block: []byte{
			0x76, 0xb8, 0xe0, 0xad, 0xa0, 0xf1, 0x3d, 0x90,
			0x40, 0x5d, 0x6a, 0xe5, 0x53, 0x86, 0xbd, 0x28,
			0xbd, 0xd2, 0x19, 0xb8, 0xa0, 0x8d, 0xed, 0x1a,
			0xa8, 0x36, 0xef, 0xcc, 0x8b, 0x77, 0x0d, 0xc7,
			0xda, 0x41, 0x59, 0x7c, 0x51, 0x57, 0x48, 0x8d,
			0x77, 0x24, 0xe0, 0x3f, 0xb8, 0xd8, 0x4a, 0x37,
			0x6a, 0x43, 0xb8, 0xf4, 0x15, 0x18, 0xa1, 0x1c,
			0xc3, 0x87, 0xb6, 0x69, 0xb2, 0xee, 0x65, 0x86,
			0x9f, 0x07, 0xe7, 0xbe, 0x55, 0x51, 0x38, 0x7a,
			0x98, 0xba, 0x97, 0x7c, 0x73, 0x2d, 0x08, 0x0d,
			0xcb, 0x0f, 0x29, 0xa0, 0x48, 0xe3, 0x65, 0x69,
			0x12, 0xc6, 0x53, 0x3e, 0x32, 0xee, 0x7a, 0xed,
			0x29, 0xb7, 0x21, 0x76, 0x9c, 0xe6, 0x4e, 0x43,
			0xd5, 0x71, 0x33, 0xb0, 0x74, 0xd8, 0x39, 0xd5,
			0x31, 0xed, 0x1f, 0x28, 0x51, 0x0a, 0xfb, 0x45,
			0xac, 0xe1, 0x0a, 0x1f, 0x4b, 0x79, 0x4d, 0x6f,
		},
	},
}

func TestLionessVectors(t *testing.T) {
	for i, v := range draftTestVectors {
		fmt.Printf("v.blocksize %d v.key %d\n", len(v.block), len(v.key))
		fmt.Printf("key %x\n", v.key)
		fmt.Printf("block %x\n", v.block)
		cipher := NewCipher(v.key, len(v.block))
		ciphertext, err := cipher.Encrypt(v.block)
		if err != nil {
			t.Errorf("[%d]: encryption failed: %s", i, err)
			continue
		}
		fmt.Printf("\nciphertext %x\n", ciphertext)
	}
}

var result []byte

func BenchmarkLioness(b *testing.B) {
	var key [LionessKeyLen]byte
	for i := 0; i < LionessKeyLen; i++ {
		key[i] = byte(i) & 0xff
	}

	plaintext := []byte("Open, secure and reliable connectivity is necessary (although not   sufficient) to excercise the human rights such as freedom of   expression and freedom of association [FOC], as defined in the   Universal Declaration of Human Rights [UDHR].  The purpose of the   Internet to be a global network of networks that provides unfettered   connectivity to all users and for any content [RFC1958].  This   objective of stimulating global connectivity contributes to the   Internet's role as an enabler of human rights.  Next to that, the   strong commitment to security [RFC1984] [RFC3365] and privacy   [RFC6973] [RFC7258] in the Internet's architectural design contribute   to the strengthening of the Internet as a human rights enabling   environment.  One could even argue that the Internet is not only an   enabler of human rights, but that human rights lie at the basis of,   and are ingrained in, the architecture of the network.  Internet   connectivity increases the capacity for individuals to exercise their   rights, the core of the Internet, its architectural design is   therefore closely intertwined with the human rights framework   [CathFloridi].  The quintessential link between the Internet's   architecture and human rights has been argued by many.  [Bless] for   instance argues that, 'to a certain extent, the Internet and its   protocols have already facilitated the realization of human rights,   e.g., the freedom of assembly and expression.  In contrast, measures   of censorship and pervasive surveillance violate fundamental human   rights.'  [Denardis15] argues that 'Since the first hints of Internet   commercialization and internationalization,")
	cipher := NewCipher(key, len(plaintext)) // key and block-size

	var err error
	var ciphertext []byte
	for i := 0; i < b.N; i++ {
		ciphertext, err = cipher.Encrypt(plaintext)
		if err != nil {
			panic(err)
		}
	}

	// always store the result to a package level variable
	// so the compiler cannot eliminate the Benchmark itself.
	result = ciphertext
}
